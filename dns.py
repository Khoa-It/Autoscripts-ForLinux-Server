import subprocess
import os

def my_log(res,success_mess, error_mess):
    if res.returncode == 0:
        print(success_mess)
    else:
        print(error_mess)
        
def checkNullAndExitProgram(val):
    if not val:
        print("Null Value")
        exit()
        
def overwrite_resolv_conf(domain, dns_server_ip):
    content = f"""# Generated by NetworkManager
search {domain}
nameserver {dns_server_ip}
nameserver 8.8.8.8
nameserver 8.8.4.4
"""
    try:
        with open("/etc/resolv.conf", "w") as file:
            file.write(content)
        print("Successfully updated /etc/resolv.conf.")
    except PermissionError:
        print("Error: Permission denied. Please run the script with sudo.")
    except Exception as e:
        print(f"An error occurred while writing to the file: {e}")
    
def generate_reverse_zone(domain,ip_address):
    network = '.'.join(ip_address.split('.')[:3])
    reverse_zone = '.'.join(network.split('.')[::-1]) + ".in-addr.arpa"
    return f""" 
zone "{reverse_zone}" IN {{
    type master;
    file "reverse.{domain}";
    allow-update {{ none; }};
}};
"""
def generate_forward_zone(domain,ip_address):
    return f""" 
zone "{domain}" IN {{
    type master;
    file "forward.{domain}";
    allow-update {{ none; }};
}};
"""

def create_zone_file(filename, content):
    try:
        path = f"/var/named/{filename}"
        with open(path, "w") as file:
            file.write(content)
        print(f"Successfully created zone file: {path}")
    except PermissionError:
        print("Error: Permission denied. Please run the script with sudo.")
    except Exception as e:
        print(f"An error occurred while creating the file: {e}")

# stop firewall
print('Stop firewall ...')
os.system('sudo systemctl stop firewalld')
print('stop firewall successfull')

# install bind
allow_install = input("Do you want to install bind for dns ? (y/n)")
if allow_install == 'y':
    os.system('yum install bind* -y')
    os.system('clear')
    print('Install successfull')
else:
    print('You dont need bind for dns !')

# change hostname
hostname = input("Enter hostname if you need: ")
if not hostname:
    print('No change host name')
else:
    command = ["hostnamectl", "set-hostname", hostname]
    result = subprocess.run(command, capture_output=True, text=True)
    my_log(res=result, success_mess='sucessfull change !', error_mess="Have error !")

ip_address = input("Enter your ip: ")
domain_name = input("Enter domain name: ")
checkNullAndExitProgram(ip_address)
checkNullAndExitProgram(domain_name)

# change name server file /etc/resolv.conf
overwrite_resolv_conf(domain_name, ip_address)

# change content file name.conf 
content_file = f"""
//
// named.conf
//
// Provided by Red Hat bind package to configure the ISC BIND named(8) DNS
// server as a caching only nameserver (as a localhost DNS resolver only).
//
// See /usr/share/doc/bind*/sample/ for example named configuration files.
//
options {{
        listen-on port 53 {{ 127.0.0.1; {ip_address}; }};
        listen-on-v6 port 53 {{ ::1; }};
        directory       "/var/named";
        forwarders {{8.8.8.8;8.8.4.4; }};
        dump-file       "/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
        secroots-file   "/var/named/data/named.secroots";
        recursing-file  "/var/named/data/named.recursing";
        allow-query     {{ localhost; }};

        /* 
         - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.
         - If you are building a RECURSIVE (caching) DNS server, you need to enable 
           recursion. 
         - If your recursive DNS server has a public IP address, you MUST enable access 
           control to limit queries to your legitimate users. Failing to do so will
           cause your server to become part of large scale DNS amplification 
           attacks. Implementing BCP38 within your network would greatly
           reduce such attack surface 
        */
        recursion yes;

        dnssec-validation yes;

        managed-keys-directory "/var/named/dynamic";
        geoip-directory "/usr/share/GeoIP";

        pid-file "/run/named/named.pid";
        session-keyfile "/run/named/session.key";

        /* https://fedoraproject.org/wiki/Changes/CryptoPolicy */
        include "/etc/crypto-policies/back-ends/bind.config";
}};

logging {{
        channel default_debug {{
                file "data/named.run";
                severity dynamic;
        }};
}};

zone "." IN {{
        type hint;
        file "named.ca";
}};

{generate_forward_zone(domain_name, ip_address)}

{generate_reverse_zone(domain_name, ip_address)}

include "/etc/named.rfc1912.zones";
include "/etc/named.root.key"; """
  
# Write content to /etc/named.conf
try:
    with open("/etc/named.conf", "w") as file:
        file.write(content_file)
    print("Successfully wrote configuration to /etc/named.conf.")
except PermissionError:
    print("Error: Permission denied. Please run the script with sudo.")
except Exception as e:
    print(f"An error occurred while writing to the file: {e}")

# create file zone and create content for that file
forward_zone_content = f"""
$TTL 86400
@   IN  SOA     ns1.{domain_name}. root.{domain_name}. (
                2023111301 ; Serial
                3600       ; Refresh
                1800       ; Retry
                604800     ; Expire
                86400 )    ; Minimum TTL

    IN  NS      ns1.{domain_name}.
@   IN  A       {ip_address}
ns1 IN  A       {ip_address}
"""
last_octet = ip_address.split('.')[-1]
# Ná»™i dung file Reverse Zone
reverse_zone_content = f"""
$TTL 86400
@   IN  SOA     ns1.{domain_name}. root.{domain_name}. (
                2023111301 ; Serial
                3600       ; Refresh
                1800       ; Retry
                604800     ; Expire
                86400 )    ; Minimum TTL

    IN  NS      ns1.{domain_name}.
{last_octet}  IN  PTR     ns1.{domain_name}.
"""

create_zone_file(f"forward.{domain_name}", forward_zone_content)
create_zone_file(f"reverse.{domain_name}", reverse_zone_content)

# check zone configuration
main_network = '.'.join(ip_address.split('.')[:3])
main_reverse_zone = '.'.join(main_network.split('.')[::-1]) + ".in-addr.arpa"
os.system(f'named-checkzone {domain_name} /var/named/forward.{domain_name}')
os.system(f'named-checkzone {main_reverse_zone} /var/named/reverse.{domain_name}')

# restart dns service
print('restart dns service...')
os.system('systemctl enable named')
os.system('systemctl restart named')

